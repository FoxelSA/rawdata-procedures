#!/bin/bash
#
# rawdata-procedures - Camera raw data procedures
#
# Copyright (c) 2013-2015 FOXEL SA - http://foxel.ch
# Please read <http://foxel.ch/license> for more information.
#
#
# Author(s):
#
#       Luc Deschenaux <l.deschenaux@foxel.ch>
#
#
# This file is part of the FOXEL project <http://foxel.ch>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# Additional Terms:
#
#       You are required to preserve legal notices and author attributions in
#       that material or in the Appropriate Legal Notices displayed by works
#       containing it.
#
#       You are required to attribute the work as explained in the "Usage and
#       Attribution" section of <http://foxel.ch/license>.

#set -e

LOG_HEADER=$(basename $0)

. $(dirname $0)/rawdata-toolbox.sh

init() {
  export MOUNTPOINT=/data
  export HOTSWAP_USING_SYS=yes
  export BASE_IP=192.168.0
  export MASTER_IP=221
  export MODULES_COUNT=9
  MUXES=(192.168.0.224 192.168.0.228)
  MUX_MAX_INDEX=(4 5)
  export SPOOL=/var/spool/rawdata-downloader

  [ -f /etc/defaults/rawdata-downloader ] && . /etc/defaults/rawdata-downloader

  # parse command line options
  if ! options=$(getopt -o hm:I:i:vdp -l help,mountpoint:,baseip:,masterip:,verbose,debug,proc -- "$@")
  then
      # something went wrong, getopt will put out an error message for us
      exit 1
  fi

  eval set -- "$options"

  while [ $# -gt 0 ] ; do
      case $1 in
      -h|--help) usage $1 ;;
      -m|--mountpoint) MOUNTPOINT=$2 ; shift ;;
      -I|--baseip) BASE_IP=$2 ; shift ;;
      -i|--masterip) MASTER_IP=$2 ; shift ;;
      -v|--verbose) VERBOSE=-v ;;
      -d|--debug) DEBUG=-d ;;
      -p|--proc) HOTSWAP_USING_SYS= ;;
      (--) shift; break;;
      (-*) echo "$(basename $0): error - unrecognized option $1" 1>&2; exit 1;;
      (*) break;;
      esac
      shift
  done

  assert_root

  mkdir -p $SPOOL || exit 1

  debugmode_update
  get_camera_macaddr
  checkdependencies

}

checkdependencies() {
  assertcommands inotifywait arp wget ssh sshall /usr/sbin/scsi-disk-udev-eventhandler
  if [ ! -f /etc/udev/rules.d/90-rawdata-downloader.rules ] ; then
    echo file not found: /etc/udev/rules.d/90-rawdata-downloader.rules >&2
    exit 1
  fi
}

usage() {
cat << EOF
  SYNOPSIS:

    $(basename $0) [OPTION ...]
  
  DESCRIPTION: 
    
    Source the specified script for every Eyesis4PI module specified

  OPTIONS SUMMARY:
  
    -h|--help                   display this
    -v|--verbose                verbose output
    -m|--mountpoint <path>      parent location of the 'camera' directory
    -I|--baseip <base_ip>       base ip, defaults to 192.168.0
    -i|--masterip <master_ip>   master camera ip, defaults to 221
    -d|--debug                  debug mode
    -p|--proc                   hotswap using proc

EOF
  exit $1
}

# add "<module_index> <mux_index> <ssd_index> <ssd_serial>" entry to MODULES_FILE
save_module_address() {
  local MUX_INDEX=$1
  local REMOTE_SSD_INDEX=$2
  local SSD_SERIAL=$3
  grep -q -E -e " $SSD_SERIAL\$" $MODULES_FILE && return 0
  echo $(get_module_index $SSD_SERIAL) $MUX_INDEX $REMOTE_SSD_INDEX $SSD_SERIAL >> $MODULES_FILE
  MODULES_FILE_TMP=/tmp/$(basename $MODULES_FILE).$$
  sort -u $MODULES_FILE > $MODULES_FILE_TMP
  cat $MODULES_FILE_TMP > $MODULES_FILE
  rm $MODULES_FILE_TMP
}

# check that specified module address match saved one
check_module_address() {
  local MUX_INDEX=$1
  local REMOTE_SSD_INDEX=$2
  local SSD_SERIAL=$3
  # ignore if not in modules file
  grep -q -E -e "^[0-9]+ $MUX_INDEX $REMOTE_SSD_INDEX " $MODULES_FILE || return 0
  # return error if serial is not matching saved one for mux/ssd pair
  grep -q -E -e " $MUX_INDEX $REMOTE_SSD_INDEX $SSD_SERIAL\$" $MODULES_FILE
}

# wait udev generated files in spool folder, then validate and save module address
wait_and_register() {

  log ${LINENO} info: wait_and_register

  local FIFO=$(mktmp -u).$$
  mkfifo $FIFO
  inotifywait -m -e close_write $SPOOL > $FIFO 2>&1
  local INOTIFY_PID=$!

  local l
  while read l ; do

    log ${LINENO} debug: INOTIFY $SPOOL $l

    local event=($l)

    # 1st string from inotifywait is not $SPOOL then it is from stderr
    [ "${event[0]}" != "$SPOOl" ] && continue

    # second string returned by inotifywait is filename (disk serial)
    local SSD_SERIAL=${event[2]}

    # get spool filename
    local UDEVINFO=$SPOOL/${event[2]}

    # get scsi host from spool filename
    local SCSIHOST=$(get_hbtl $UDEVINFO)
    [ -z "$SCSIHOST" ] && killtree -KILL $MYPID

    # get saved connecting disk info
    local DISK_CONNECTING_INFO=($(cat $DISK_CONNECTING_TMP))
    local MUX_INDEX=${DISK_CONNECTING_INFO[0]}
    local REMOTE_SSD_INDEX=${DISK_CONNECTING_INFO[1]}
    local ISRETRY=${DISK_CONNECTING_INFO[2]}
    local DEVICE=$(grep DEVNAME "$UDEVINFO" | cut -f 2 -d '=')

    log ${LINENO} info: device_connected $MUX_INDEX $REMOTE_SSD_INDEX $SCSIHOST $SSD_SERIAL $DEVICE

    # assert previously saved module address match the connecting disk
    check_module_address $MUX_INDEX $REMOTE_SSD_INDEX $SSD_SERIAL 2>&1 | logstdout ${LINENO}
    if [ ${PIPESTATUS[0]} -ne 0 ] ; then
      log ${LINENO} error: "saved serial for mux $MUX_INDEX ssd $REMOTE_SSD_INDEX is not matching $SSD_SERIAL"
      killtree -KILL $MYPID
    fi

    # cache camera module address (mux index, ssd index)
    save_module_address $MUX_INDEX $REMOTE_SSD_INDEX $SSD_SERIAL 2>&1 | logstdout ${LINENO}

    # cache mux index and scsi host association
    save_scsihost $MUX_INDEX $SCSIHOST

    # if disk is already connected, ignore
    [ -f $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connected ] && continue

    log ${LINENO} info: unpause connect queue
    touch $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connecting || killtree -KILL $MYPID

    # set already connected flag
    touch $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connected || killtree -KILL $MYPID
    echo $SCSIHOST $SSD_SERIAL $DEVICE > $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connected

    enqueue_next_ssd $MUX_INDEX $REMOTE_SSD_INDEX $SCSIHOST $SSD_SERIAL $DEVICE $ISRETRY &

  done < $FIFO

  kill -TERM $INOTIFY_PID > /dev/null 2>&1 
}

# enqueue next ssd for this mux
enqueue_next_ssd() {
  local MUX_INDEX=$1
  local REMOTE_SSD_INDEX=$2
  local SCSIHOST="$3 $4 $5 $6"
  local SSD_SERIAL=$7
  local DEVICE=$8
  local ISRETRY=$9

  # quit if already processed - should not happend
  if [ -f $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_processed ] ; then
    log ${LINENO} error: already processed
    killtree -KILL $MYPID
  fi

  # sync filesystems
  log ${LINENO} info: syncing
  sync

  remove_scsi_device

  # remove flag
  rm $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connected || killtree -KILL $MYPID

  # set processed flag
  touch $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_processed || killtree -KILL $MYPID
  echo $SCSIHOST $SSD_SERIAL $DEVICE $STATUS > $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_processed

  # add serial to processed list
  echo $SSD_SERIAL >> $SSD_SERIAL_DONE_TMP

  # show progression
  local SSD_SERIAL_DONE_COUNT=$(sort -u $SSD_SERIAL_DONE_TMP | wc -l)
  log ${LINENO} info: registration_done_count $SSD_SERIAL_DONE_COUNT

  # enqueue this mux's next ssd for backup (ignore this step for retries)
  if [ "$ISRETRY" = "" -a $REMOTE_SSD_INDEX -lt ${MUX_MAX_INDEX[$MUX_INDEX]} ] ; then
    log ${LINENO} debug: enqueue mux $MUX_INDEX ssd $((REMOTE_SSD_INDEX+1))
    echo $MUX_INDEX $((REMOTE_SSD_INDEX+1)) >> $CONNECT_Q_TMP

  else
    # it is a retry or MUX_MAX_INDEX has been reached
    if ! is_any_ssd_left_in_queue_for_mux $MUX_INDEX ; then
      MUX_DONE=$(cat $MUX_DONE_TMP)
      echo $((++MUX_DONE)) > $MUX_DONE_TMP
    fi
    log ${LINENO} info: mux_done_count $MUX_DONE

  fi

  # exit when all muxes have been processed
  if [ "$MUX_DONE" = "${#MUXES[@]}" ] ; then

    if [ $(sort -u $SSD_SERIAL_DONE_TMP | wc -l) -eq $MODULES_COUNT ] ; then
      log ${LINENO} info: "SUCCESS - all modules processed successfuly"
      log ${LINENO} info: exit_status 0
      echo 0 > $EXIT_CODE_TMP

    else
      log ${LINENO} error: "FAILURE - some modules could not be processed"
      log ${LINENO} error: exit_status 1
      echo 1 > $EXIT_CODE_TMP

    fi

    killtree -KILL $MYPID

  fi
}

is_any_ssd_left_in_queue_for_mux() {
   export MUX_INDEX=$1
   QSEQ=$(cat $QSEQ_TMP)
   tail -n +$(($QSEQ+1)) $CONNECT_Q_TMP | cut -f 1 -d ' ' | grep -q -e '^'$MUX_INDEX'$'
}

# switch esata connections sequentially reading from $CONNECT_Q_TMP
connect_q_run() {

  log ${LINENO} info: "connect_q_run"

  local FIFO=$(mktemp -u).$$
  mkfifo $FIFO
  tail -f $CONNECT_Q_TMP > $FIFO 2>&1 &
  local TAIL_PID=$!

  while read INDEXES ; do

    # increment queue sequence number
    echo $((++QSEQ)) > $QSEQ_TMP

    # parse queue request
    INDEXES=($INDEXES)
    MUX_INDEX=${INDEXES[0]}
    REMOTE_SSD_INDEX=${INDEXES[1]}
    ISRETRY=${INDEXES[2]}

    # requeue again if other disk of this mux is already connected
    if [ -f $TMP/${MUX_INDEX}_*_connected ] ; then
      echo $MUX_INDEX $REMOTE_SSD_INDEX $ISRETRY >> $CONNECT_Q_TMP
      sleep 10
      continue
    fi

    log ${LINENO} debug: connect_q_run processing mux $MUX_INDEX ssd $REMOTE_SSD_INDEX

    while true ; do

      # before requesting disk connection, setup inotifywait and timemout to pause queue until disk is connected or timeout occurs
      touch $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connecting || killtree -KILL $MYPID

      INOTIFY_STDERR=$(mktemp)
      timeout -k 10 30 inotifywait -e close_write $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connecting > /dev/null 2> $INOTIFY_STDERR &
      TIMEOUTPID=$!
      wait_regexp $INOTIFY_STDERR "Watches established" 2>&1 | grep -v -e INOTIFY_STDERR | logstdout ${LINENO}

      # before requesting disk connection, save connecting disk info
      echo $MUX_INDEX $REMOTE_SSD_INDEX $ISRETRY > $DISK_CONNECTING_TMP

      # request disk connection
      log ${LINENO} info: requesting sata disk mux $MUX_INDEX index $REMOTE_SSD_INDEX
      log ${LINENO} debug: wget http://${MUXES[$MUX_INDEX]}/103697.php?c:host4=ssd$REMOTE_SSD_INDEX
      wget -q http://${MUXES[$MUX_INDEX]}/103697.php?c:host4=ssd$REMOTE_SSD_INDEX -O - > /dev/null || killtree -KILL $MYPID

      sleep 10
      add_scsi_device

      # wait for inotifywait and timeout setup above
      log ${LINENO} info: waiting for mux $MUX_INDEX disk $REMOTE_SSD_INDEX
      wait $TIMEOUTPID
      timeout_status=$?

      log ${LINENO} debug: timeout status $timeout_status wating for mux $MUX_INDEX disk $REMOTE_SSD_INDEX

      rm $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connecting

      # exit loop if there was no timeout
      [ "$timeout_status" != "124" ] && break

      # timeout on retry ? exit
      [ -n "$ISRETRY" ] && killtree -KILL $MYPID

      # re-enqueue this mux/ssd pair for later
      log ${LINENO} debug: requeue mux $MUX_INDEX index $REMOTE_SSD_INDEX single
      echo $MUX_INDEX $REMOTE_SSD_INDEX isretry >> $CONNECT_Q_TMP

      # ask next ssd index for this mux
      [ $REMOTE_SSD_INDEX -lt ${MUX_MAX_INDEX[$MUX_INDEX]} ] || break
      ((++REMOTE_SSD_INDEX))

    done
  done < $FIFO
  kill -TERM $TAIL_PID > /dev/null 2>&1
  rm $FIFO
}

########### main script

SCSIHOST=()

init "$@"

[ -z "$MOUNTPOINT" ] && MOUNTPOINT=$1 && shift

if [ -z "$MOUNTPOINT" -o "$#" -gt 0 ] ; then
  usage 1
fi

checkdependencies

TMP=/tmp/rawdata-downloader/$MACADDR/$$
mkdir -p $TMP

# create shared variables and inter-process storage
export EXIT_CODE_TMP=$(mktemp --tmpdir=$TMP)
export DISK_CONNECTING_TMP=$(mktemp --tmpdir=$TMP)
export SSD_SERIAL_TMP=$(mktemp --tmpdir=$TMP)
export REMOVED_DEVICES=$(mktemp --tmpdir=$TMP)
export CONNECT_Q_TMP=$(mktemp --tmpdir=$TMP)
export MUX_DONE_TMP=$(mktemp --tmpdir=$TMP)
export QSEQ_TMP=$(mktemp --tmpdir=$TMP)
export SSD_SERIAL_DONE_TMP=$(mktemp --tmpdir=$TMP)
export REMOVED_SCSI_TMP=$TMP/../removed_scsi

echo 1 > $EXIT_CODE_TMP
echo 0 > $QSEQ_TMP
echo 0 > $MUX_DONE_TMP
touch $REMOVED_SCSI_TMP

wait_until_camera_awake

# clear scsi hosts cache if modification time older than camera uptime
export SCSIHOST_TMP=$TMP/../scsihosts
if [ -f $SCSIHOST_TMP ] ; then
  if [ $CAMERA_UPTIME -lt $(modtime $SCSIHOST_TMP) ] ; then
    echo -n > $SCSIHOST_TMP
  fi
else
  touch $SCSIHOST_TMP
fi

# set destination folder
DEST="$MOUNTPOINT/$(echo $MACADDR | tr 'a-f' 'A-F')"

mkdir -p "$DEST/rawdata-downloader" || exit 1
export MODULES_FILE="$DEST/rawdata-downloader/modules"

export SSHALL_HOSTS=$(build_sshall_login_list)

get_camera_ssd_serials

log ${LINENO} info: got ${#SSD_SERIAL[@]} SSD serials

[ ${#SSD_SERIAL[@]} -ne $MODULES_COUNT ] && exit 1

rm $SSD_SERIAL_TMP

# unmount camera ssd
log ${LINENO} info: umount CF
umount_all 2>&1 | logstdout ${LINENO}

# wait for disks and register modules in background
wait_and_register &

connect_queue_init

# run queue in background
log ${LINENO} info: starting queue processing
connect_q_run &

# wait background jobs termination
wait

# disable ctrl-c
trap '' SIGINT

# reset multiplexers
log ${LINENO} info: resetting multiplexers
reset_eyesis_ide

restore_scsi_devices

EXIT_CODE=$(cat $EXIT_CODE_TMP)

[ $EXIT_CODE -eq 0 ] && echo $MODULES_FILE

# remove temporary files
rm $TMP -r 2> /dev/null

log ${LINENO} info: exit $EXIT_CODE
exit $EXIT_CODE

