#!/bin/bash
# connect-modules - connect requested eyesis module
#
# Copyright (c) 2015 FOXEL SA - http://foxel.ch
# Please read <http://foxel.ch/license> for more information.
#
#
# Author(s):
#
#       Luc Deschenaux <l.deschenaux@foxel.ch>
#
#
# Contributor(s):
#
#       Kevin Velickovic <k.velickovic@foxel.ch>
#
#
# This file is part of the FOXEL project <http://foxel.ch>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# Additional Terms:
#
#       You are required to preserve legal notices and author attributions in
#       that material or in the Appropriate Legal Notices displayed by works
#       containing it.
#
#       You are required to attribute the work as explained in the "Usage and
#       Attribution" section of <http://foxel.ch/license>.

#set -e

export __CONNECT_MODULE__=$(basename $0)
export MYPID=$BASHPID

# delay script execution if another instance is running yet
no_concurrency() {

  PIDFILE=/var/run/connect-module.pid

  # wait for concurrent process exit
  [ -s "$PIDFILE" ] && OLDPID=$(cat $PIDFILE)
  [ -n "$OLDPID" -a "$OLDPID" != "$MYPID" ] && while [ "$(grep Name /proc/$OLDPID/status 2>/dev/null | cut -f 2)" == "$__CONNECT_MODULE__" ] ; do
    sleep 1
  done 

  # lock this process
  echo $MYPID > $PIDFILE

}


# extract MAC address from arp cache for given IP
macaddr() {
  local _ADDR=$1
  arp -n $_ADDR | awk '/[0-9a-f]+:/{gsub(":","-",$3);print $3}'
}

# parse command line options and set environment variables
init() {

  assert_root
  no_concurrency

  # set default values
  export MUXES=(192.168.0.224 192.168.0.228)
  export SPOOL=/var/spool/rawdata-downloader
  export MOUNTPOINT=/data
  export BASE_IP=192.168.0
  export MASTER_IP=221

  # read preferences
  [ -f /etc/defaults/rawdata-downloader ] && . /etc/defaults/rawdata-downloader

  # parse command line
  if ! options=$(getopt -o hvm:I:i:snd -l help,verbose,mountpoint:,baseip:,masterip,hotswap-use-sys,no-checklist,debug: -- "$@")
  then
      # something went wrong, getopt will put out an error message for us
      exit 1
  fi

  eval set -- "$options"

  while [ $# -gt 0 ] ; do
      case $1 in
      -h|--help) usage $1 ;;
      -v|--verbose) export VERBOSE=-v ;;
      -m|--mountpoint) export MOUNTPOINT=$2 ; shift ;;
      -I|--baseip) export BASE_IP=$2 ; shift ;;
      -i|--masterip) export MASTER_IP=$2 ; shift ;;
      -s|--hotswap-use-sys) export HOTSWAP_USING_SYS=yes ;;
      -n|--no-checklist) export NO_CHECKLIST=true ;;
      -d|--debug) export DEBUG=1 ;;
      (--) shift; break;;
      (-*) echo "$(basename $0): error - unrecognized option $1" 1>&2; exit 1;;
      (*) break;;
      esac
      shift
  done

  # get camera MAC address
  if [ -z "$MACADDR" ] ; then

    # get camera master ip mac address
    if ! ping -w 5 -c 1 $BASE_IP.$MASTER_IP > /dev/null ; then
      log ${LINENO} unable to ping $BASE_IP.$MASTER_IP
      exit 1
    fi

    MACADDR=$(macaddr $BASE_IP.$MASTER_IP | tr 'a-f' 'A-F')

    if [ -z "$MACADDR" ] ; then
      log ${LINENO} "unable to get MAC address for $BASE_IP.$MASTER_IP"
      exit 1
    fi

  fi


  # check modules file exist
  export MODULES_FILE=$MOUNTPOINT/camera/$MACADDR/info/rawdata-downloader/modules
  if [ ! -f $MODULES_FILE ] ; then
    log ${LINENO} error file not found: $MODULES_FILE
    log ${LINENO} "=> run 'build-modules-file $MOUNTPOINT' first"
    exit 1
  fi

  # remaining parameter is the requested module number
  [ -z "$MODULE" ] && MODULE=$1 && shift

  # ... or die
  if [ -z "$MODULE" ] ; then
    usage 1
  fi

  # ... or die
  [ $# -gt 0 ] && usage 1

  
  mkdir -p $SPOOL || exit 1

  # debug flags
  if [ -n "$DEBUG" ] ; then 
    set -x
    set -v
    export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
  fi

}

init "$@"

# assert user is root
assert_root() {
  if [ $UID -ne 0 ] ; then
    echo error: $(basename $0) must be run as root >&2
    exit 1
  fi
}

assertcommands() {
  while [ $# -ne 0 ] ; do
    local CMD=$1
    shift
    [ -z "$(which $CMD)" ] && echo command $CMD not found >&2 && exit 1
  done
}

checkdependencies() {
  assertcommands inotifywait arp wget ssh sshall /usr/sbin/scsi-disk-udev-eventhandler
  if [ ! -f /etc/udev/rules.d/90-rawdata-downloader.rules ] ; then
    echo file not found: /etc/udev/rules.d/90-rawdata-downloader.rules >&2
    exit 1
  fi
}

usage() {
  echo "usage: $(basename $0) <camera_module_index>" >&2
  exit $1
}

# kill child processes, and optionally the root process
killtree() {

    # disable ctrl-c
    trap '' SIGINT

    local _pid=$2
    local _sig=$1
    local killroot=$3

    # stop parents children production between child killing and parent killing
    #[ "${_pid}" != "$MYPID" ] && kill -STOP ${_pid}
    for _child in $(ps -o pid --no-headers --ppid ${_pid} 2>/dev/null); do
        killtree ${_sig} ${_child} yes
    done
    [ -n "$killroot" ] && (kill ${_sig} ${_pid} >/dev/null 2>&1 && wait ${_pid} > /dev/null 2>&1) > /dev/null 2>&1
}

umount_cf() {
  HOSTS=$USER_AT_HOST sshall << 'EOF'
if grep -q ' /usr/html/CF ' /proc/mounts ; then
  sync
  umount /usr/html/CF || exit 1
  sync
fi
exit 0
EOF
}

get_remote_disk_serial() {
  HOSTS=$USER_AT_HOST sshall /sbin/hdparm -i $1 \| sed -r -n -e "'s/.*SerialNo=([^ ]+).*/\1/p'"
}

get_local_disk_serials() {
  for DEV in /dev/sd? ; do
    echo $DEV,$(hdparm -i $DEV | sed -r -n -e 's/.*SerialNo=([^ ]+).*/\1/p')
  done
}

get_hbtl() {
  grep DEVPATH= $1 | sed -r -n -e 's#.*/([0-9]:[0-9]:[0-9]:[0-9])/.*#\1#' -e T -e 's/:/ /gp'
}

log() {
  [ -z "$VERBOSE" ] && return
  echo $(date +%F_%r) $__CONNECT_MODULE__ $BASHPID $@ >&2
}

# format stdin for logging
logstdout() {
  [ -z "$VERBOSE" ] && return
  while read l ; do
    echo $(date +%F_%R:%S) $__CONNECT_MODULE__ $BASHPID $@ $l >&2
  done
}

# return array index of serial
get_ssd_index() {
  local _SERIAL=$1
  local index
  for (( index=0 ; $index < ${#SSD_SERIAL[@]} ; ++index )) ; do
    if [ "${SSD_SERIAL[$i]}" = "$_SERIAL" ] ; then
      echo $index
      break
    fi
  done
}

# seconds since file modification
modtime() {
  local filename="$1"
  expr $(date +%s) - $(stat -c %Y "$filename")
}

get_camera_uptime() {
  ssh root@$BASE_IP.$MASTER_IP cat /proc/uptime | cut -f 1 -d '.'
}

# get module info (mux index serial) from module number
get_module_info() {
  local MODULE_NUMBER=$1
  grep -E -e "^$MODULE_NUMBER " $MODULES_FILE 
}

# compare specified module details with saved one
check_module_address() {
  local MUX_INDEX=$1
  local REMOTE_SSD_INDEX=$2
  local SERIAL=$3
  # return error if serial is not matching saved one for mux/ssd pair
  grep -q -E -e " $MUX_INDEX $REMOTE_SSD_INDEX $SERIAL\$" $MODULES_FILE
}

# wait udev generated files in spool folder before exiting
wait_and_exit() {

  log ${LINENO} "<= wait_and_exit"

  # use FIFO instead of PIPE, to exit loop smoothly
  local FIFO=$(mktemp -u).$$
  mkfifo $FIFO
  inotifywait -m -e close_write $SPOOL 2>/dev/null > $FIFO &
  local INOTIFY_PID=$!
 
  while read l ; do

     set -x
     set -v
    log ${LINENO} $SPOOL INOTIFY $l

    # second string returned by inotifywait is filename (disk serial)
    event=($l)
    SERIAL=${event[2]}

    # get spool filename
    UDEVINFO=$SPOOL/${event[2]}

    # get scsi host from spool filename
    SCSIHOST=$(get_hbtl $UDEVINFO)
    [ -z "$SCSIHOST" ] && killtree -KILL $MYPID

    # get saved connecting disk info
    DISK_CONNECTING_INFO=($(cat $DISK_CONNECTING_TMP))
    _MUX_INDEX=${DISK_CONNECTING_INFO[0]}
    _REMOTE_SSD_INDEX=${DISK_CONNECTING_INFO[1]}
    ISRETRY=${DISK_CONNECTING_INFO[2]}
    DEVICE=$(grep DEVNAME "$UDEVINFO" | cut -f 2 -d '=')

    log ${LINENO} device_connected $_MUX_INDEX $_REMOTE_SSD_INDEX $SCSIHOST $SERIAL $DEVICE

    log ${LINENO} unpause connect queue         
    touch $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connecting || killtree -KILL $MYPID                                   

    [ "$_MUX_INDEX" != "$MUX_INDEX" ] && continue
    [ "$_REMOTE_SSD_INDEX" != "$REMOTE_SSD_INDEX" ] && continue

    # assert previously saved module address match the connecting disk
    if ! check_module_address $_MUX_INDEX $_REMOTE_SSD_INDEX $SERIAL 2>&1 | logstdout ${LINENO} ; then
      log ${LINENO} invalid_address "saved serial for mux $MUX_INDEX ssd $REMOTE_SSD_INDEX is not matching  $SERIAL"

    else
      # success
      echo $DEVICE
      echo 0 > $EXIT_CODE_TMP

    fi

    # kill inotify so that break can exit loop
    kill $INOTIFY_PID > /dev/null 2>&1
    wait $INOTIFY_PID > /dev/null 2>&1

    break

  done < $FIFO

  killtree -KILL $MYPID
}

wait_watches_established() {

  local INOTIFY_STDERR=$1
  local msg

  local FIFO=$(mktemp -u).$$
  mkfifo $FIFO
  tail -f $INOTIFY_STDERR > $FIFO 2>&1 &
  local TAIL_PID=$!

  while read msg ; do
    echo $msg | logstdout ${LINENO}
    [[ "$msg" =~ "Watches established" ]] && break
  done < $FIFO

  kill $TAIL_PID > /dev/null 2>&1
  wait $TAIL_PID > /dev/null 2>&1

  rm $INOTIFY_STDERR $FIFO
}

# request esata connection for MUX_INDEX / REMOTE_SSD_INDEX
request_ssd() {

  log ${LINENO} "<= run"

    MUX_INDEX=$MUX_INDEX
    REMOTE_SSD_INDEX=$REMOTE_SSD_INDEX
    ISRETRY=

    log ${LINENO} going to request mux $MUX_INDEX ssd $REMOTE_SSD_INDEX

    while true ; do

      # before requesting disk connection, setup inotifywait and timemout to pause queue until disk is connected or timeout occurs
      touch $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connecting || killtree -KILL $MYPID

      INOTIFY_STDERR=$(mktemp)
      timeout -k 10 30 inotifywait -e close_write $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connecting > /dev/null 2> $INOTIFY_STDERR &
      TIMEOUTPID=$!
      wait_watches_established $INOTIFY_STDERR 2>&1 | grep -v -e INOTIFY_STDERR | logstdout ${LINENO}

      # before requesting disk connection, save connecting disk info
      echo $MUX_INDEX $REMOTE_SSD_INDEX $ISRETRY > $DISK_CONNECTING_TMP

      # request disk connection
      log ${LINENO} requesting sata disk mux $MUX_INDEX index $REMOTE_SSD_INDEX
      log ${LINENO} wget http://${MUXES[$MUX_INDEX]}/103697.php?c:host4=ssd$REMOTE_SSD_INDEX
      wget -q http://${MUXES[$MUX_INDEX]}/103697.php?c:host4=ssd$REMOTE_SSD_INDEX -O - > /dev/null || killtree -KILL $MYPID

      # wait for inotifywait and timeout setup above
      log ${LINENO} waiting for mux $MUX_INDEX disk $REMOTE_SSD_INDEX
      wait $TIMEOUTPID 2> /dev/null
      timeout_status=$?

      log ${LINENO} timeout status $timeout_status wating for mux $MUX_INDEX disk $REMOTE_SSD_INDEX

      rm $TMP/${MUX_INDEX}_${REMOTE_SSD_INDEX}_connecting

      # exit loop if there was no timeout
      [ "$timeout_status" != "124" ] && break

      # timeout on retry ? exit
      [ -n "$ISRETRY" ] && killtree -KILL $MYPID

      ISRETRY=yes

    done

} # run

# unmount ssd on cameras
mount_all() {
  STATUS=()
  mount_cf 2>&1 | tee | while read l ; do
    msg=($l)
    [ ${msg[0]} = "sshall:" ] || continue
    LOGIN=${msg[1]}
    [ -z "$LOGIN" ] && echo umount_all: $l >&2 && killtree -KILL $MYPID
    WHAT=${msg[2]}
    [ "$WHAT" != "status" ] && continue
    IP=$(echo $LOGIN | sed -r -n -e 's/.*@[0-9]+\.[0-9]+\.[0-9]+\.([0-9]+).*/\1/p')
    INDEX=$(expr $IP - $MASTER_IP)
    STATUS[$INDEX]=${msg[3]}
    [ "${STATUS[$INDEX]}" != "0" ] && echo mount_cf $IP >&2 && killtree -KILL $MYPID
  done
}

# unmount ssd on cameras
umount_all() {
  STATUS=()
  umount_cf 2>&1 | tee | while read l ; do
    msg=($l)
    [ ${msg[0]} = "sshall:" ] || continue
    LOGIN=${msg[1]}
    [ -z "$LOGIN" ] && echo umount_all: $l >&2 && killtree -KILL $MYPID
    WHAT=${msg[2]}
    [ "$WHAT" != "status" ] && continue
    IP=$(echo $LOGIN | sed -r -n -e 's/.*@[0-9]+\.[0-9]+\.[0-9]+\.([0-9]+).*/\1/p')
    INDEX=$(expr $IP - $MASTER_IP)
    STATUS[$INDEX]=${msg[3]}
    [ "${STATUS[$INDEX]}" != "0" ] && echo umount_cf $IP >&2 && killtree -KILL $MYPID
  done
}

########### main script

SCSIHOST=()

checkdependencies

TMP=/tmp/mount_module/$MACADDR/$$
mkdir -p $TMP

# create shared variables and inter-process storage
export MYPID=$BASHPID
export EXIT_CODE_TMP=$(mktemp --tmpdir=$TMP)
export DISK_CONNECTING_TMP=$(mktemp --tmpdir=$TMP)
export SSD_SERIAL_TMP=$TMP/../serials

echo 1 > $EXIT_CODE_TMP

trap "killtree -9 $MYPID yes" SIGINT SIGKILL SIGTERM SIGHUP

export SCSIHOST_TMP=$TMP/../scsihosts

if [ -z "$NO_CHECKLIST" ] ; then

  log ${LINENO} get camera uptime
  CAMERA_UPTIME=$(get_camera_uptime)
  if [ -z "$CAMERA_UPTIME" ] ; then
    log ${LINENO} cannot get camera uptime
    exit 1
  fi

  if [ $CAMERA_UPTIME -lt 120 ] ; then
    log ${LINENO} wait $((120-CAMERA_UPTIME)) seconds for camera wake up
    sleep $((120-CAMERA_UPTIME))
  fi

  # clear scsi hosts cache if modification time older than camera uptime
  if [ -f $SCSIHOST_TMP ] ; then
    if [ $CAMERA_UPTIME -lt $(modtime $SCSIHOST_TMP) ] ; then
      echo -n > $SCSIHOST_TMP
    fi
  fi
fi

touch $SCSIHOST_TMP

MODULE_INFO=($(get_module_info $MODULE))
SERIAL=${MODULE_INFO[3]}

for pair in $(get_local_disk_serials) ; do 

  pair=($(echo $pair | tr ',' ' '))

  # is requested module ssd is already connected ?
  if [ "$SERIAL" == "${pair[1]}" ] ; then
    # then print device and exit
    echo "${pair[0]}"
    exit 0
  fi
    
done

USER_AT_HOST="$USER_AT_HOST "root@$BASE_IP.$((MASTER_IP + MODULE - 1))

[ -f "$SSD_SERIAL_TMP" ] && . $SSD_SERIAL_TMP

if [ -z "${SSD_SERIAL[$((MODULE-1))]}" ] ; then

  # get camera ssd serials
  STATUS=()
  log ${LINENO} get ssd serial
  export SSD_SERIAL=()
  get_remote_disk_serial /dev/hda 2>&1 | while read l ; do
    msg=($l)
    if [ ${msg[0]} != "sshall:" ] ; then
      log ${LINENO} get_remote_disk_serial: $l
      continue
    fi
    [ ${msg[2]} = "stderr" ] && log ${LINENO} get_remote_disk_serial: $l
    LOGIN=${msg[1]}
    [ -z "$LOGIN" ] && log ${LINENO} get_remote_disk_serial: $l && killtree -KILL $MYPID
    IP=$(echo $LOGIN | sed -r -n -e 's/.*@[0-9]+\.[0-9]+\.[0-9]+\.([0-9]+).*/\1/p')
    INDEX=$(expr $IP - $MASTER_IP)
    WHAT=${msg[2]}
    case "$WHAT" in
    status)
      STATUS[$INDEX]=${msg[3]}
      [ "${STATUS[$INDEX]}" != "0" ] && log ${LINENO} "error: $l" && log ${LINENO} "error: hdparm failed on camera $IP with exit code ${STATUS[$INDEX]}" && killtree -KILL $MYPID
      ;;
    stdout)
      SERIAL=${msg[3]}
      echo SSD_SERIAL[$INDEX]=$SERIAL >> $SSD_SERIAL_TMP
      ;;
    esac
  done

fi

. $SSD_SERIAL_TMP

#[ ${#SSD_SERIAL[@]} - 1 ] && exit 1

if [ "${SSD_SERIAL[$((MODULE-1))]}" != "$SERIAL" ] ; then
  log ${LINENO} error: ssd serial mismatch "(${SSD_SERIAL[$((MODULE-1))]}" '!=' "$SERIAL)"
  exit 1
fi

# unmount camera ssd
log ${LINENO} umount CF
umount_all | logstdout ${LINENO}

export MUX_INDEX=${MODULE_INFO[1]}
export REMOTE_SSD_INDEX=${MODULE_INFO[2]}

# run backgroud task waiting for disks and launching backups
wait_and_exit &

# run queue in background
log ${LINENO} starting processing

request_ssd &

# wait background jobs termination
wait 2> /dev/null

# disable ctrl-c
trap '' SIGINT

EXIT_CODE=$(cat $EXIT_CODE_TMP)

# remove temporary files
rm $TMP/$$ -r 2> /dev/null

# kill zombies
killtree -KILL $MYPID

log ${LINENO} exit $EXIT_CODE
exit $EXIT_CODE
